
# selogger の機能

selogger は，Java プログラムの実行履歴を *それなりに* 詳しく記録することを目指したツールです．


## 使用方法

準備するもの: 解析対象プログラムと，そのプログラムを実行するための入力データ等が必要です．


1. 解析対象プログラム（バイナリ）のバイトコード変換を実行，対象プログラムに観測用命令を埋め込んでください．
    * 実行に必要なクラス:  selogger のクラス群と lib ディレクトリのすべての JAR ファイルを classpath に設定してください．main クラスは selogger.weaver.TraceWeaver です．
    * 引数として，解析対象プログラムのクラスファイルが入っているディレクトリ，あるいは JAR ファイル，クラスファイルを指定します．複数指定することもできます．
    * 指定したディレクトリに格納されている JAR ファイルを解析対象とする場合は -jardir オプションを付けてください（指定しないとディレクトリ内部のクラスファイルだけが対象になります）．
    * JAR ファイルの中に入っている JAR ファイルも解析対象とする場合は -innerJAR オプションを付けてください．DaCapoベンチマークなどを相手にするときに必要です．
    * バイトコード変換の結果や変換途中のエラーログ，解析時に使用するデータファイルを書き出すディレクトリを -output=path/to/dir オプションで指定します．指定しないとカレントディレクトリに出力されます．
    * JDK 1.6 以前のファイルを対象としているときは -jdk16 を指定してください．指定し忘れると，プログラム実行の段階で VerifyError が検出されます．
    * エラーでも停止しないようにしたい場合は -ignoreError を指定します．このオプションを指定すると，変換時にエラーが起きたクラスは変換せずコピーを作るようになります．DaCapoベンチマークのように，解析エラーが起きるファイルを意図的に格納しているJARファイルを扱う場合に必要です．
    * 取得したいイベントの種類を変更したい場合は -weave= オプションで指定してください．-weave=ALL と指定するとすべての命令を観測します．EXEC,CALL,ARRAY,FILED,MISC,LABEL,PARAM の7種類をカンマで区切って指定でき，メソッドの実行，呼び出し，配列の操作，フィールドアクセス，その他のオブジェクト操作命令（MONITORとINSTANCEOF），条件分岐等によるラベル通過，引数の値を記録できます．デフォルトはラベル以外のすべてです．
    * デバッグ用: 変換後のバイトコード情報を -verify オプションで出力できます．各メソッドのすべての内容を出力するため，大規模プログラムに適用するとディスク容量を圧迫する可能性があります．
    
2. 変換された解析対象プログラムを，selogger/bin ディレクトリ以下のクラス群を classpath に含めた状態で実行してください（libディレクトリの他のクラスには依存しません）．-output で指定したディレクトリに weave 結果の JAR やクラスファイルが出力されるので，クラスパスにこれらのクラスと selogger のクラス群を指定した状態で対象プログラムを実行してください．このとき有効なVMオプションは次の通りです．
    * -Dselogger.dir=ディレクトリ名.  ログを書き出すディレクトリを指定してください．
    * -Dselogger.threads=スレッド数．ログをバックグラウンドでディスクに書き出すスレッド数．1つあたりRAMが400MB程度必要．デフォルトは0．SSDでCPUにも余裕があればは4～6程度が有効です．
    * -Dselogger.errorlog=ファイル名．I/O例外などが発生したときにエラーログを書き出すファイル．ディスク溢れなどのエラーについては，ログ書き出し先と別ディスクでないと意味がないことがあります．指定しなければどこにも書き出しません．
    * -Dselogger.output=出力形式．固定長・圧縮あり(fixed-compress)が標準．variable とすると可変長無圧縮で，10倍以上のディスク容量を消費するかわりRAMディスク上では非常に高速になります．profile と指定すると，ログを書き出すかわりにイベントの出現頻度表をテキスト形式で出力します．

3. 出力されたログを解析します．
    * LogPrinter クラスを main として，-dir=ディレクトリ名 という形式で -Dselogger.dir のディレクトリを指定すると，そのログの内容を単純に標準出力に書き出します．
    * selogger.reader.LogDirectory, EventReader クラスを使って，自分で解析のためのプログラムを作成してください．   

以上の3ステップを selogger の testdata パッケージに対して実行する例を Windwos 用バッチファイルとして testdata.bat.txt に記述してあります．
Windows 環境では拡張子を .bat に変換すると実行することが可能です．

## 実装済みの機能

* JARファイルへの weaving に対応．
* 記録できるイベント
  * メソッドの実行開始 (EVENT_METHOD_ENTER)，終了 (EVENT_METHOD_NORMAL_EXIT, EVENT_METHOD_EXCEPTIONAL_EXIT)．仮引数 (EVENT_FORMAL_PARAM)．
  * メソッド呼び出し命令の実行 (EVENT_METHOD_CALL) と実引数 (ACTUAL_PARAM)．呼び出しからの復帰に対しては，たとえ戻り値の型が void であっても EVENT_RETURN_VALUE_AFTER_CALL が記録される．コンストラクタ呼び出しの場合は，かわりに初期化されたオブジェクトが記録される（EVENT_OBJECT_CREATION_COMPLETED）．コンストラクタの中でさらに上位のコンストラクタを使った場合の部分的な初期化の完了は EVENT_OBJECT_INITIALIZEDとして記録される．
  * 配列の読み書き，フィールドの読み書き．フィールドと配列の読み出しでは，試した事実と，読みだした値を両方記録する（アクセス時に例外が発生する可能性があるので個別のイベントとして記録）．
* JDK 1.8 までのバイトコードに対応．
  * JDK 1.7 からバイトコードに Stack Map という情報が必要になったが，これを再計算するためにクラス階層情報が要求される場合がある？（正確な理由は不明）．
  * クラスが不足している場合は，weaving 実行じに -classpath で該当コードへのクラスパスを通すと実行に成功する．
* Weave に使ったパラメータ設定（WeavingInfo）は，それ自体が出力ディレクトリに書き出される．現状では，対象クラスの一覧などは含まれていない（Weaver に切り離されている）．



## selogger の構成要素

### Weaver (selogger.weaverパッケージ)

観測したい対象の Java プログラムに対してバイトコード変換を実行し，ログを記録するための命令を埋め込みます．

かなりの量の命令を追加で埋め込むことになるため（たとえば１つのメソッド呼出しに対して，呼出しが生じたことと完了したこと，引数の値を書き出しにいきます），バイトコードの量がJavaの制限を超えるようなプログラムに対しては観測を行うことができません．

### ログの記録 (selogger.logging パッケージ)

ログを実際にファイルに書き出す機能を担当するクラス群です．
Logging がその代表を務めており，Weaver は Logging クラスへの呼出しを埋め込みます．

イベント内容をデータフォーマットに対応させる仕事は LogWriter が担っています．

### 解析 (selogger.reader パッケージ)

ログファイルを読みだす側の仕事を担当するクラス群です．
LogDirectory クラスが作業の起点となります．
FullTraceValidation に，ログの内容をチェックする仕組みを試作してあります．


### その他の構成要素

* tests ディレクトリ以下には，実験用に作られたいくつかのテストコードが格納されています．
  * com.insidious.agent.testdata は，バイトコードWeavingの実験対象であり，意図的にJavaの特定の命令を使ったり例外を起こしたりする命令が埋め込んであります．
* old ディレクトリに過去の試作品が格納されているが，これらは古いログ形式に対応したもので，現在のバージョンには適用できません．



## Weave 実行時に出力されるデータファイル

ログ取得用コードの埋め込みは，クラスファイル自体が破損している場合や，埋め込んだ結果として対象ファイルが非常に大きくなってしまう場合に失敗します．
Weaver は自動でログ取得を簡素化して再度 Weaving を試みます．
最終的に対象になったクラスのリストが classes.txt に，途中で発生したエラーは log.txt に書き込まれれます．

  * classes.txt には，クラスの通し番号，クラスが格納されていたJARあるいはディレクトリ，クラスファイルの名前，クラスの名前，Weavingの成否，クラスの内容に関するMD5ハッシュコードが書き出されます．現状では classes.txt に出てくるクラスの名前は絶対パスになっていますので，出力されたファイルを別計算機・別ディレクトリに移動して解析する場合には注意してください．
  * LogLevel.IgnoreArrayInitializer: path/to/aClass.class というメッセージは，配列の初期化（たとえば `new int[]{1, 2, 3}`）における数値の代入処理をログ取得から外したときに表示されます．
  * LogLevel.OnlyEntryExit: path/to/aClass.class というメッセージは，対象クラスのどれかのメソッドが非常に大きいため，メソッドへの進入と脱出（ENTRY, EXIT）のみを取得するようにログ取得コードを埋め込んだ場合に表示されます．
  * Failed to weave ... というメッセージは，ログ取得コードを何らかの原因で埋め込めなかった場合に表示されます．たとえばDaCapoベンチマークに収録されている org/apache/derbyTesting/databaseclassloader/emc.class は，テスト用に作られた「壊れた」クラスファイルです．

いずれのメッセージでも，これらの対象クラスについては正確な結果が求められていないかもしれない，という事実に注意して解析を行う必要があります（多くの場合はテスト用コードや，巨大な配列の初期化テーブルが原因なので，そこまで甚大な影響はないでしょうが）．


## ログの内容

* イベントは，スレッドに関係なく，時系列で順番に詰め込まれた系列として記録されます．
* 各イベントには，イベントID，コード位置ID，スレッドIDが付いています．同じコード位置を複数のスレッドが通過しうるので，スレッドIDの確認は必須です．
  * 全メソッド呼び出しについて：誰が（this），誰に（receiver），引数
  * 全メソッド呼び出しの完了した時点で：戻り値
  * 全メソッドの実行先頭で：引数(this含む)
  * 全メソッドの実行完了時点(return)で戻り値
  * 全メソッドの例外発生時(catch (Throwable))で例外オブジェクト
  * 配列の生成について：できあがったID，配列のサイズ．
  * 多次元配列の生成について：できあがった一番外側のID（今後修正予定）
  * 配列参照について：誰に（target），インデクス(index)，読み書きされた値
  * フィールドについて：誰に（target），フィールドID，読み書きされた値


* スレッドごとにイベントを分析すると，次の順序関係を保つ．

        method ::= METHOD_ENTRY  FORMAL_PARAM*  instruction  (METHOD_NORMAL_EXIT|METHOD_EXCEPTIONAL_EXIT)
        instruction ::= METHOD_CALL  ACTUAL_PARAM*  method?  (RETURN_VALUE_AFTER_CALL|OBJECT_INITIALIZED|OBJECT_CREATION_COMPLETED)
                      | THROW
                      | GET_INSTANCE_FIELD
                      | method? GET_STATIC_FIELD
                      | ARRAY_LOAD  
                      | ARRAY_STORE
                      | PUT_INSTANCE_FIELD
                      | PUT_INSTANCE_FIELD_BEFORE
                      | PUT_STATIC_FIELD
                      | NEW_ARRAY
                      | MULTI_NEW_ARRAY
                      | ARRAY_LENGTH 
                      | INSTANCEOF


  * `method?` は，クラスの static member が初めて参照されたときに生じるクラスの読み込みに伴う `<clinit>` を表現しています． 
  * 例外が起きた場合は，もし catch ブロックがあれば `EVENT_CATCH` として記録される．もし直前のイベントが `ARRAY_LOAD, GET_*_FIELD, CALL` であれば，これらが失敗していることになります．
    * catch ブロックがない場合は `METHOD_EXCEPTIONAL_EXIT` に到達する．このときも直前のイベントが `ARRAY_LOAD, GET_*_FIELD, CALL` であれば，これらが失敗していることになります．
  * -wave=ALL などとしてWeaver実行時にLABEL記録をONにしておくと，条件分岐等による「LABEL」の通過を確認することができ，ブランチカバレッジの計算に使用できます．
  * 引数の値を記録しない（-weave=PARAMを指定していない）状態では，戻り値は記録されませんが，メソッド呼び出しが終わったことを示すために void 型の `RETURN_VALUE_AFTER_CALL` が記録されます．


## ログに記録されていない情報

* ローカル変数の状態．メソッドの引数などから再現することは可能です．
* 行単位での命令の通過．制御フロー情報は書いてあるので，自分で計算することは可能です．
