
# What is selogger?

selogger is a toolkit for recording an execution trace of a Java program.


## Usage

You must have a target Java application and a test case to execute the program.


1. Execute selogger.weaver.TraceWeaver to insert logging code into the target program.
    * To execute TraceWeaver, please include selogger classes and all jar files in lib directory in -classpath.
    * TraceWeaver takes as input class file names, directory names and zip file names.  
    * If a directory name is specified, class files are listed up for weaving.  If you want to automatically list up JAR files in a directory, specify `-jardir` option.
    * If you want to weave jar files in a jar file recursively, specify -innerJAR option.
    * TraceWeaver outputs woven files to the current directory.  If you want to change a directory, please specify `-output=path/to/dir` option.
    * TraceWeaver weaves bytecode for JDK 1.7 and 1.8.  If your program is JDK 1.6 or earlier, please specify `-jdk16`.  Without the option, a woven program may cause a verify error.
    * TraceWeaver termintes if an error occurs during a weaving process.  If you want to ignore errors, specify `-ignoreError`.  The option skips weaving for class files that cause an error.  Some applications, e.g. DaCapo benchmark, include an invalid class file intentionally.  This option can ignore such a file.  The weaving result is recorded in a log file.
    * If you want to specify events to be recorded, please specify `-weave=` option.  `-weave=ALL` records all events.  The option accepts 6 sub-options listed by commas (`EXEC,CALL,ARRAY,FILED,MISC,LABEL,PARAM`).  Executions, method calls, array read/write, field read/write, some instructions (e.g. monitor entry/exit and instanceof), control-flow labels, and parameter values.  By default, selogger records all events except for labels.
    
2. Execute the woven target program with class files in selogger/bin directory.  Other jar files in lib directory is unnecessary.  You may specify the following options.
    * -Dselogger.dir=log-directory-name specifies a directory for an execution trace.  You should specify a disk that has enough space.
    * -Dselogger.threads=[0-8] specifies the number of background threads to write an execution trace into a disk.   Each thread requires about 400MB RAM for a buffer.  The default value is 0.  If you have enough CPU power and fast disks, you may specify e.g. 2 or 4, to speed up an execution.
    * -Dselogger.errorlog=filename specifies an error log file.  Since an execution trace may cause a disk full error, you may specify another directory from the trace directory.  If not specified, an error log is not output.
    * -Dselogger.output=profile option outputs a frequency table of events instead of writing an execution trace.   This option enables to estimate an execution trace size.

3. Analyze an execution trace.
    * LogPrinter is a basic program that simply print out the contents of an execution trace.  The printer class takes `-dir=path/to/trace` option to specify an execution trace directory (that is specified as `-Dselogger.dir` directory).
    * Create your own analysis program with selogger.reader.LogDirectory and EventReader classes. 

testdata.bat.txt is an example batch file for Windows to execute the three steps described above for testdata package in selogger.
You may execute it by removing the com.insidious.plugin.extension .txt.


## Features

* TraceWeaver supports bytecode weaving for jar files.
* Events recorded by this tool is listed in `events-en.html`.
* TraceWeaver supports JDK 1.6, 1.7, and 1.8.  1.8 is experimental implementation.



## Data files generated by TraceWeaver

  * classes.txt contains a list of woven class files.  Each line shows a sequential ID of a class, the jar/directory name of the class file, class file name, class name, weaving result, MD5 hash of the class binary. 
  * If a weaving process encounters a runtime error, messages are recorded in log.txt.
  * LogLevel.IgnoreArrayInitializer: path/to/aClass.class indicates a method in the class is too large to insert logging code for array initialization.
  * LogLevel.OnlyEntryExit: path/to/aClass.class indicates a method in the class is too large to insert logging code.  Only entry/exit events are recorded for the class.
  * Failed to weave ... message indicates TraceWeaver could not process a file.  For example, TraceWeaver shows this message for org/apache/derbyTesting/databaseclassloader/emc.class in the DaCapo benchmark suite, because the file is a broken class file. 


## Event Stream

* An execution trace of a single thread comprises a stream of events as follows.

        method ::= METHOD_ENTRY  FORMAL_PARAM*  instruction  (METHOD_NORMAL_EXIT|METHOD_EXCEPTIONAL_EXIT)
        instruction ::= METHOD_CALL  ACTUAL_PARAM*  method?  (RETURN_VALUE_AFTER_CALL|OBJECT_INITIALIZED|OBJECT_CREATION_COMPLETED)
                      | THROW
                      | GET_INSTANCE_FIELD
                      | method? GET_STATIC_FIELD    
                      | ARRAY_LOAD
                      | ARRAY_STORE
                      | PUT_INSTANCE_FIELD
                      | PUT_INSTANCE_FIELD_BEFORE
                      | PUT_STATIC_FIELD
                      | NEW_ARRAY
                      | MULTI_NEW_ARRAY
                      | ARRAY_LENGTH
                      | INSTANCEOF


  * `method?` is inserted between events when JVM loads a class and executes its static initializer (`<clinit>`).
  * An exception is recorded as `EVENT_CATCH`.  If the previous event is one of `ARRAY_LOAD, GET_*_FIELD, CALL` events, the exception is likely caused by the operation.
    * If there are no catch block, `METHOD_EXCEPTIONAL_EXIT` is found in a trace.  
  * If labels are recorded in an execution trace (by specifying `-weave=ALL` option), label events are inserted between events.
  * Even if parameters are unrecorded (PARAM is not specified in -weave option), `RETURN_VALUE_AFTER_CALL` events with void type (without values) are recorded to indicate the end of a method call.


## What is not recorded in an execution trace?

* Local variables are not recorded in a trace.  You may recover the state by replaying an execution of a method from parameters of a method, array access events, and field access events.
